{% import "views/_im.njk" as im %}
# 即时通讯服务总览

即时通讯是 LenaCloud 平台的核心服务之一，主要解决了产品内实时数据通讯的需求，现在已经被广泛使用在应用内聊天、客服系统、超大型赛事和电视直播、以及游戏状态同步等多种场合。LeanCloud 即时通讯服务的主要目标有：

* 支持现有应用快速加入多种通讯能力。
  市场上很多产品都已经达到一个比较稳定的形态，即时通讯只是其中一个锦上添花的功能，所以如何和现有系统无缝集成，是我们设计上一个重要的出发点。LeanCloud 即时通讯服务可以在应用账户系统独立的情况下，快速接入并稳定安全地运行。我们支持了多种典型通讯场景，提供了丰富的 UI 库和脚手架来帮助开发者快速接入。而且考虑到业务运行环境，我们提供了全平台支持的 SDK，不光浏览器（Javascript）、Android、iOS 上可以调用我们的原生 SDK，Java/Python/PHP 等服务端运行环境，微信小程序和小游戏，Unity3D，甚至 Windows Desktop 环境都有合适的 SDK 可选。
* 强大的自定义机制满足业务各种扩展需求。
  我们内置提供了文本、图片、音视频、地理位置、二进制等多种类型的消息，默认提供了强大的系统管理与运营支持能力，也支持消息撤回与修改、敏感词实时过滤等高阶需求。但是我们也明白业务系统的复杂性和多样性，所以设计上就预留了很多的自定义接口，允许产品开发者来扩展自己的消息类型、UI 样式以及各种会话流程的控制。
* 最大限度降低客户的生产运维成本。
  作为专业的通讯云服务提供商，我们希望客户不再担心用户量/流量的涨落，也无需关心系统运维细节，并且费用支出和实际使用量多少是正相关的关系，这样的模式才是云服务该有的样子。

## 功能和特性

LeanCloud 即时通讯服务提供的主要功能有：

* 基本聊天功能
  - 支持多种类型的对话。除了普通的单聊、群聊（成员数最大不超过 500）之外，还有不限人数的「开放聊天室」（适合超大规模用户在一个群里的聊天互动，如直播、公开课、电视红包等场合），「临时对话」（适合临时建立的无需上下文的场合，如客服系统），以及「系统对话」（可订阅对话，可用来实现公众号和系统账号等）。
  - 用户之间可以发送多种多样的消息，如文本、图片、语音、音视频、地理位置等，也可以发送二进制消息，以及更多的应用层自定义消息。
* 特殊的消息操作
  除了普通的消息收发之外，我们还支持带有提醒功能的 @ 消息（如微信里面的 @ 某人）、消息的撤回和修改，以及对方离线状态下自动转为推送通知（Push Notification）。
  另外，对于大型的开放聊天室，为了防止重要消息被淹没或丢弃，我们也支持不同优先级的发送选项，确保重要的消息能优先、迅速送达客户端。
* 管理与运营支持
  对于大的群组和开放聊天室，我们提供了管理员/普通成员的权限管理功能，也支持邀请、踢人、黑名单和禁言等众多运营管理需求。
  对于聊天消息，我们默认提供了敏感词实时过滤的能力，允许各个产品设置自己的敏感词列表，并且也支持开发者实现自己的敏感词过滤插件，来确保产品运营层面合规合法。
* 安全控制
  任何终端用户要开启即时通讯服务，只需要提供一个唯一标识自己的 clientId 即可，这种与产品自有账户系统解耦合的方式，带来了集成的便利，也可以促使通讯服务商专注做好底层的「信使」角色。
  同时我们也提供第三方鉴权的机制，通过在聊天流程中加入开发者服务端签名授权这一环节，来确保通讯过程的安全。
  而且，即时通讯 SDK 与 LeanCloud 云端是 WebSocket 全双工通讯，且全程使用 TLS 安全加密。
* 多端登录与消息同步
  我们支持单个设备多个账号、单个账号多个设备同时登录，实时消息同步到所有设备。对话发生时如果对方离线，会自动通过 [消息推送](#离线推送通知) 来及时通知对方有新的消息，并且推送的消息文本可以由开发者自己控制。
* 强大的业务扩展能力
  对于很多典型的需求，我们会提供默认的实现，而为了支持业务的多样性和特殊性，我们也提供了多种扩展机制。
  - 为了和产品自有用户系统进行对接，我们提供了第三方操作鉴权的扩展接口，确保在用户登录、创建/加入/退出对话群组、以及拉取聊天记录时，所有操作都得到了授权。
  - 同时我们还支持开发者对消息传递的过程进行 hook 处理，在消息到达 LeanCloud 云端但是还没有投递之前和投递之后，分别完成自定义的处理逻辑，例如过滤掉竞品的品牌，以及自定义离线推送消息，等等。
  - 我们也支持通过简单的 web hook 来完成 LeanCloud 云端和应用后端的消息同步。
  - 在提供移动端的 SDK 之外，我们还提供了服务端的 SDK，以帮助产品在可信环境下更好地实现业务处理。
  我们相信灵活性和扩展性也是云服务的核心竞争力。

## 跨平台的客户端 SDK 和 Demo 支持

目前，我们提供了 Android/Java、iOS（Objective-C / Swift 两个版本）、浏览器（JavaScript）、Unity、微信（小程序和小游戏）、Windows Desktop 等主要平台的客户端 SDK，而且所有 SDK 的源代码都是公开的，开发者可以在我们的 github 账户下自由下载，可以与我们工程师同步讨论遇到的问题和需求。

在 SDK 之外，我们也公开了一些 Demo 项目来帮助开发者快速熟悉我们的产品，主要的 demo 有：

* iOS 聊天应用：
  * [ChatKit，自带 UI 的聊天工具包](chatkit-ios.html)

* Android 聊天应用：
  * [ChatKit，自带 UI 的聊天工具包](chatkit-android.html)
  * [LeanChat Android 版](https://github.com/leancloud/leanchat-android)

* JavaScript 聊天应用
  * [LeanMessageDemo 网页版](https://github.com/leancloud/leanmessage-demo)
  * [Simple Chatroom](https://leancloud.github.io/js-realtime-sdk/demo/simple-chatroom/)（[源码](https://github.com/leancloud/js-realtime-sdk/tree/next/demo/simple-chatroom)）


关于这些项目的更多介绍、截图预览，可见 [LeanCloud Demos](https://github.com/leancloud/leancloud-demos) 。

## 核心概念

在开始接入之前，我们先跟大家解释几个核心的概念，这些概念在 SDK API 或者后面的开发指南中都会出现，了解它们会让后续的文档阅读变得简单和轻松很多。

### ClientID、用户和登录

即时通讯服务中的每一个终端称为一个 client。client 拥有一个在应用内唯一标识自己的 id。这个 id 由应用自己定义，必须是不超过 64 个字符的字符串。在大部分场合，client 都可以对应到应用中的某个「用户」，但是并不是只有真的用户才能做为 client，你完全可以把一个探测器当成一个 client，把它收集到的数据通过即时通讯服务广播给更多「人」。

默认情况下，LeanCloud 即时通讯服务允许一个 clientId 在多个不同的设备上登录，也允许一个设备上有多个 clientId 同时登录。如果使用场景中需要限制用户只在一处登录，可以在登录时明确设置当前设备的 tag，
当 LeanCloud 云端检测到同一个 tag 的设备出现冲突时，会自动踢出已存在设备上的登录状态。开发者可以根据自己的应用场景选择合适的登录方式。

使用 LeanCloud 即时通讯 SDK 完成登录后，开发者就不必关心网络连接等状态，SDK 会自动为开发者保持连接状态，并根据网络状态自动重连。对于 Android 平台，我们使用常驻后台的服务保持在线状态；对于 iOS 和 Windows Phone
等平台，我们会在应用仍在前台时保持连接，当应用退到后台时，自动断开连接再激活平台原生的推送服务。

### 对话（Conversation）

用户登录之后，与其他人进行消息沟通，即为开启了一个对话（Conversation）。开始聊天之前，需要先创建或者加入一个对话，然后再邀请其他人进来，之后所有参与者在这个对话内进行交流。所有消息都是由某一个 client 发往一个「对话」。

系统每创建一个对话，就会在云端的 `_Conversation` 表中增加一条记录，可以进入 [控制台 > **存储** > **数据**](/data.html?appid={{appid}}#/) 来查看该数据。

`_Conversation` 表中字段名与对话的各个属性的对应关系为：

表字段|属性名|类型|约束|说明
---|---|---|---|---
**attr**|attributes|Object|可选|自定义属性，供开发者扩展使用。
**objectId**|conversationId|String||对话 id（只读），由云端为该对话生成的一个全局唯一的 id。
**c**|creator|String||对话创建者的 clientId（只读）
**lm**|lastMessageAt|Date||对话中最后一条消息的发送或接收时间
**m**|members|Array||普通对话的所有参与者（仅针对普通对话，暂态对话和系统对话并不支持持久化的成员列表）
**mu**|mute|Array||将对话设为静音的参与者，这部分参与者不会收到推送。<br/>（仅针对 iOS、 Windows Phone 以及开启了混合推送的 Android 用户有效）
**name**|name|String|可选|对话的名字，可为群组命名。
**tr**|transient|Boolean|可选|是否为暂态对话
**sys**|system|Boolean|可选|是否是系统对话
**unique**|unique|Boolean|可选|内部字段，标记根据成员原子创建的对话。

除了在各平台的 SDK 里面可以调用 API 创建对话外，我们也提供 REST API 可以让大家预先建立对话：对话的信息存储在 _Conversation 表中。

这里要特别讨论一下**单聊**、**群聊**、**聊天室**、**公众号**等使用场景。

* **单聊**<br/>
  就是两个 client 之间的对话，公开与否（能否让其他人看到这个对话存在）由应用层自己控制。一般而言，它是私密的，并且加入新的成员之后，会切换到新的对话（当然，也可以依然不离开当前对话，这一点还是由应用层来决定）。
* **群聊**<br/>
  就是两个（含）以上 client 之间的对话，一般而言，可以添加和删除成员，并且会赋予群聊一个名字。随着成员的减少，群聊也可能只有两个甚至一个成员（成员的多少并不是区分群聊和单聊的关键）。群聊能否公开（譬如支持名字搜索），由应用自己决定。
* **聊天室**<br/>
  很多应用使用的聊天室、弹幕、网页直播等都可以抽象成「聊天室」，它与群聊类似，都是多人参与的群组，但是也有一些区别：其一在于聊天室人数可能远大于群聊人数；其二在于聊天室强调的是在线人数，所有参与者进入聊天界面就算加入，关闭界面就算退出，所以聊天室不需要离线消息和推送通知，在线成员数比具体成员列表更有意义。
* **公众号、机器人**<br/>
  对全部或者部分用户可见（由应用开发者决定）的账号，开发者可以利用这个账号给用户发广播通知，用户也可以通过这个账号反馈内容给开发者，开发者可以在后台看到消息，也可以利用 API 或 [Web Hook](#Web_Hook) 将自己的业务系统集成进来。

我们将以上场景抽象为「对话」这一概念，并分离出以下类型的对话：

#### 普通对话（Conversation）

这是我们经常会用到的「对话」，单聊和群聊都通过它来实现。我们建议开发者将单聊/群聊、私密/公开等属性存入到 Conversation.attributes 之中，在应用层进行区别对待。

为了提高系统的灵活性，我们允许多个对话保持相同的成员，因此创建对话时系统总是默认创建新的对话。
如果开发者希望使用固定的对话，可以在创建对话时设置相应 SDK 上的 `unique` 选项，系统将查找对应成员相同且 `unique` 选项为 true 的对话，如果找到即返回已有的对话，如果没有则自动创建。
（注意，这种方式查找的对话仅对已经使用 `unique` 选项的对话有效，并且创建对话时不会触发 `_Conversation` 表在云引擎上的 `beforeSave` 等 hook）

REST API 在创建对话时同样支持 `unique` 参数。

对于应用中存在系统帐号的场景，我们建议您通过下文提到的[系统对话](#普通对话_Normal_Conversation_)来实现，以避免对单一帐号创建过多的对话影响您应用的性能。

#### 开放聊天室（ChatRoom，也叫 Transient Conversation）

专门用来处理「聊天室」这种需求。与普通对话一样，它支持创建、自身主动加入、自身主动退出对话等操作；消息记录会被保存并可供获取；但不同之处在于：

* **不限成员上限**，没有固定成员概念，加入即为成员，断线即为退出
* 不支持查询成员列表，你可以通过相关 API 查询在线人数。
* 不支持离线消息、离线推送通知等功能。
* 没有成员加入、离开的通知。
* 不支持邀请加入、踢出成员这两个操作。
* 一个用户一次登录只能加入一个暂态对话，加入新的暂态对话后会自动离开旧的暂态对话。
* 加入暂态对话后半小时内断网重连会自动加入原暂态对话，超过这个时间则需要重新加入。
* 在 `_Conversation` 表中，以 `tr` 为 `true` 来标记（`m`列在暂态对话中将被忽略）

注意开放聊天室没有持久化的成员概念，因此对普通对话的 `m` 字段的操作对暂态对话无效。

#### 系统对话（System Conversation）

这是用于实现机器人、公众号、服务账号等场景的对话，也可以用作发送应用内通知的通道。这种对话具有以下特点：

* 加入即订阅，离开即退订，支持无限的订阅人数
* 开发者可以通过 REST API 以系统对话的渠道给所有用户、订阅用户或指定用户（不要求用户订阅）发消息
* 用户可以给系统对话发消息，消息和相关信息会存储在数据存储中的 `_SysMessage` 表，并不会被其他订阅用户收到
* 开发者可以配置 [Web Hook](#Web_Hook) 地址接收用户发给系统对话的消息，并利用 REST API 发消息回复
* 在 SDK 层面，系统对话的接口与普通对话完全一致
* 在 `_Conversation` 表中，以 `sys` 为 `true` 来标记（`m`列在系统对话中将被忽略）

#### 临时对话（Temporary Conversation）

这是用于实现机器人、公众号、服务账号等场景的对话，也可以用作发送应用内通知的通道。这种对话具有以下特点：

* 加入即订阅，离开即退订，支持无限的订阅人数
* 开发者可以通过 REST API 以系统对话的渠道给所有用户、订阅用户或指定用户（不要求用户订阅）发消息
* 用户可以给系统对话发消息，消息和相关信息会存储在数据存储中的 `_SysMessage` 表，并不会被其他订阅用户收到
* 开发者可以配置 [Web Hook](#Web_Hook) 地址接收用户发给系统对话的消息，并利用 REST API 发消息回复
* 在 SDK 层面，系统对话的接口与普通对话完全一致
* 在 `_Conversation` 表中，以 `sys` 为 `true` 来标记（`m`列在系统对话中将被忽略）

#### 对话类型比较

功能点 | 普通对话 | 开放聊天室 | 系统对话 | 临时对话
--- | --- | --- | ---
**使用场景** | 单聊、群聊 | 聊天室、弹幕、网页实时评论 | 公众号、机器人、下发加好友通知、自定义消息
**成员管理** | 成员持久化保存，<br/>最高支持 500 个成员 | 没有持久化的成员数据，<br/>但支持成员没有上限 | 没有成员概念，<br/>开发者维护订阅关系，<br/>订阅人数没有上限
**收发消息** | 只有成员可以收发消息 | 所有用户都可以发消息，<br/>当前在线的成员可以收到消息 | 开发者通过 API 给特定用户发消息，<br/>用户发送的消息到达数据库和 [Web Hook](#Web_Hook)
**消息记录** | 支持 | 支持 | 支持


### 消息（Message）

即时通讯服务的消息。用户可以一次传输不超过 **5 KB** 的文本数据。在底层即时通讯允许开发者传输任何基于文本的消息数据，系统对消息格式没有任何要求，
开发者可以在文本协议基础上定义自己的应用层协议。

消息分为「普通消息」和「暂态消息」。LeanCloud 云端对于普通消息会提供接收回执、自动持久化存储、离线推送等功能。
但是暂态消息，则不会被自动保存，也不支持延迟接收，离线用户更不会收到推送通知，所以适合用来做控制协议。
譬如聊天过程中「某某正在输入中...」这样的状态信息，就适合通过暂态消息来发送，而用户输入的正式消息，则应该用普通消息来发送。

我们对普通消息提供「至少一次」的到达保证，并且在官方 SDK 中支持对消息的去重，开发者无需关心。除了基于「推」模型的消息机制，我们还提供消息记录的机制允许
SDK 和 REST API 通过「拉」的方式获取任意时间点前的消息。

开发者可以通过 SDK 或 REST API 发送消息。
SDK 通常用于最终用户发送消息，而 REST API 是开发者从云端发送消息的接口。当从 REST API
发送消息时，开发者可以指定消息的发送者、对话 ID，对于系统对话还可以指定消息的接收者。

{{ im.messagesLifespan("") }}

#### 富媒体消息

为了方便开发者的使用，我们提供了几种封装好的基于 JSON 格式的富媒体消息类型（TypedMessage），譬如：

- 文本（TextMessage）
- 图片（ImageMessage）
- 音频（AudioMessage）
- 视频（VideoMessage）
- 位置（LocationMessage）

这些消息类型可最大程度地简化使用步骤，能更好地满足通用需求。开发者也可以基于我们的框架，方便地扩展出自己的消息类型。

这些消息类型的层次关系为：

```
                                    Message
                                       |
                                  TypedMessage
                                       |
     __________________________________|__________________________________
     |             |            |             |               |           |
TextMessage  ImageMessage  AudioMessage  VideoMessage  LocationMessage   。。。
```

关于这部分消息的格式请参考
[《即时通讯 REST API - 富媒体消息格式说明》](realtime_rest_api.html#富媒体消息格式说明)了解。

#### 离线消息

开发者可以通过 [**控制台** > **消息** > **实时消息** > **帮助**](/messaging.html?appid={{appid}}#/message/realtime/tool) 界面查询某个 Client ID 的在线状态和离线消息数。

当用户重新登录后，LeanCloud 提供两种方式进行下发离线消息：

1. **默认方式**：云端会对每个对话推送至多最近 20 条消息。这部分消息在用户上线后会以新消息的形式到达客户端，对于轻量级的应用这种方式可以满足开发者对离线消息的需求；
2. **未读数量方式**：云端会返回离线期间产生未读消息的对话列表及未读消息数，开发者可以根据这个通知拉取离线消息记录收取离线消息，这种方式下开发者对消息的数量可以完全的控制；

<div class="callout callout-danger">注意，请不要混合使用上面两种方式，比如在 iOS 平台使用默认方式获取离线消息而 Android 平台使用未读数量方式获取离线消息。这种情况可能导致离线消息无法正常获取。</div>

#### 离线推送通知

对离线的 iOS、Windows Phone 和开启了混合推送的 Android 用户，每次有离线消息时，我们提供发送离线推送通知的功能。要想使用本功能，用户需要 **自定义推送的内容**，目前有三种方式，按优先级从高到低依次为：

1. 动态内容方式

  如果希望推送通知显示动态内容，比如消息的实际内容，或根据消息内容、对话信息等上下文信息来自定义内容，则需要通过 [云引擎 Hook `_receiversOffline`](#_receiversOffline) 来实现。该类型优先级最高。

2. 消息附件方式
  
  - 对于 SDK，通过各个 SDK 提供的 API 设置这条消息可能产生的推送内容，比如 JS 的是 [pushData 参数](https://leancloud.github.io/js-realtime-sdk/docs/Conversation.html#send)
  - 对于 REST，通过 [push_data 参数](./realtime_rest_api_v2.html#发消息)设定

3. 静态内容方式

  由于不同平台的不同限制，且用户的消息正文可能还包含上层协议，所以我们允许用户在控制台中为应用设置一个静态的 JSON，推送一条内容固定的通知。
  {% if node=='qcloud' %}
  进入 `控制台 > 消息 > 实时消息 > 设置 > 离线推送设置`，填入：
  {% else %}
  进入 [控制台 > 消息 > 实时消息 > 设置 > 离线推送设置](/messaging.html?appid={{appid}}#/message/realtime/conf)，填入：
  {% endif %}
  ```
  {"alert":"您有新的消息", "badge":"Increment"}
  ```
  注意，`badge` 参数为 iOS 设备专用，且 `Increment` 大小写敏感，表示自动增加应用 badge 上的数字计数。清除 badge 的操作请参考 [iOS 推送指南 &middot; 清除 badge](ios_push_guide.html#清除_Badge)。
  
  ![image](images/realtime_ios_push.png)

  此外，对于 iOS 设备您还可以设置声音等推送属性，具体的字段可以参考[推送 &middot; 消息内容 Data](./push_guide.html#消息内容_Data)。

##### 限制

通知的过期时间是 7 天，也就是说，如果一个设备 7 天内没有连接到 APNs、MPNs 或设备对应的混合推送平台，系统将不会再给这个设备推送通知。

##### 原理

这部分平台的用户，在完成登录时，SDK 会自动关联当前的 Client ID 和设备。关联的方式是通过设备**订阅**名为 Client ID 的 Channel 实现的。开发者可以在数据存储的 `_Installation` 表中的 `channels` 字段查到这组关联关系。在实际离线推送时，系统根据用户 Client ID 找到对应的关联设备进行推送。由于即时通讯触发的推送量比较大，内容单一， 所以云端不会保留这部分记录，在 **控制台 > 消息 > 推送记录** 中也无法找到这些记录。

##### 其他设置

推送默认使用**生产证书**，你也可以在 JSON 中增加一个 `_profile` 内部属性来选择实际推送的证书，如：

```json
{
  "alert":    "您有一条未读消息",
  "_profile": "dev"
}
```

Apple 不支持在一次推送中向多个从属于不同 Team Id 的设备发推送。在使用 iOS Token Authentication 的鉴权方式后，如果应用配置了多个不同 Team Id 的 Private Key，请确认目标用户设备使用的 APNs Team ID 并将其填写在 `_apns_team_id` 参数内，以保证推送正常进行，只有指定 Team ID 的设备能收到推送。如：

```json
{
  "alert":    "您有一条未读消息",
  "_apns_team_id": "my_fancy_team_id"
}
```

`_profile` 和 `_apns_team_id` 属性均不会实际推送。

目前，设置界面的推送内容支持部分内置变量，你可以将上下文信息直接设置到推送内容中：

* `${convId}` 推送相关的对话 ID
* `${timestamp}` 触发推送的时间戳（Unix 时间戳）
* `${fromClientId}` 消息发送者的 Client ID

#### 敏感词过滤

根据政策的要求，我们为多人的普通对话、暂态对话和系统对话进行敏感词过滤。

过滤的词库由 LeanCloud 提供，命中的敏感词将会被替换为 `***`。

支持用户自定义敏感词过滤文件。在 [控制台 > 消息 > 实时消息 > 设置](/dashboard/messaging.html?appid={{appid}}#/message/realtime/conf) 中开启「消息敏感词实时过滤功能」，上传敏感词文件即可。

如果开发者有较为复杂的过滤需求，我们推荐使用 [云引擎 hook _messageReceived](#_messageReceived) 来实现过滤，在 hook 中开发者对消息的内容有完全的控制力。

#### 广播消息

当开发者需要向所有用户发送广播消息时，可以利用广播消息的接口，而无需遍历所有的用户 ID 逐个发送。

广播消息具有以下特征：

* 广播消息必须与系统对话关联，广播消息和一般的系统对话消息会混合在系统对话的记录中
* 用户离线时发送的广播消息，上线后会作为离线消息收到
* 广播消息具有实效性，可以设置过期时间；过期的消息不会作为离线消息发送给用户，不过仍然可以在历史消息中获取到
* 新用户第一次登录后，会收到最近一条未过期的系统广播消息

除此以外广播消息与普通消息的处理完全一致。广播消息的发送可以参考[广播消息 REST API](./realtime_rest_api_v2.html#全局广播)


## 系统限制

* 对于客户端主动发起的操作会按照操作类型限制其频率。发消息操作限制为 **每分钟 60 次**，历史消息查询操作限制为 **每分钟 120 次**，其他类型操作包括加入对话、离开对话、登录服务、退出服务等均限制为 **每分钟 30 次**。当调用超过限制时，云端会拒绝响应这些超限的操作，这样如果操作本由 SDK 发起则表现为不会走回调。如果使用 REST API 发起各种操作，则不会受到上述频率的限制。
* 应用全局服务器下发消息速度默认为每秒钟 160000 次，超过部分会被服务器丢弃。如果你的应用会超过此限制，请 [联系我们](/help.html)。
* 通过 API 发送的消息有发送速率限制。最高每秒钟 50 次请求，超过该速率后服务器会对发送的消息做排队缓存，如果排队待发送的消息超过 10000 条则会拒绝新来的发消息请求。
* 客户端发送的单条消息大小不得超过 5 KB。
* 单个普通对话的成员上限为 500 个，如果您通过数据存储 API 向 m 字段加入了超过 500 个 id，我们只会使用其中的前 500 个。
* 请不要使用相同的 id 在大量设备上同时登录，如果系统检测到某个 id 同时在超过 5 个不同的 IP 上登录，会认为此 id 是重复使用的 id，之后此 id 当日的每次登录会按照 `id + IP` 的组合作为计费的独立用户。
* 如果单个用户有超过 50 个的对话存在未接收的离线消息，那么当该用户登录时服务端只会**随机**下发 50 个对话的离线消息或未读消息数量。也就是说服务端不会再下发超出对话数量限制的那部分离线消息，也不会下发离线消息数量，离线消息不会丟失但需要从历史记录中拉取得到。
* 单个对话未接收的离线消息数最多 100 条，超过后，系统会以先入先出方式存储新的离线消息，同时移除当前对话存储的最早的一条离线消息。被移除的离线消息可以通过历史消息记录查询，但不会产生离线消息提醒，也不会计入对话的未读消息计数。
* 系统广播消息一个应用一天最多发 30 条

{{ im.conversationsLifespan("### 对话的有效期") }}

{{ im.messagesLifespan("### 消息的有效期") }} 


## 云引擎 Hook

详见 [消息 hook 接口和系统对话使用详解](realtime-guide-systemconv.html)。

## 开发指南

按功能区分，可以参考如下文档：
- [1. 从简单的单聊、群聊、收发图文消息开始](realtime-guide-beginner.html)
- [2. 玩转开放聊天室和公众号，允许撤回和修改消息，以及离线通知](realtime-guide-intermediate.html)
- [3. 解决权限管理、敏感词过滤、多端同步等需求的方法](realtime-guide-senior.html)
- [4. 消息 hook 接口和系统对话使用详解](realtime-guide-systemconv.html)

按客户端开发语言和平台区分，可以参考：
- [Android 开发指南](realtime_guide-android.html)
- [iOS 开发指南](realtime_guide-objc.html)
- [JavaScript 开发指南](realtime_guide-js.html)。

服务端开发指南，可以参考：[Python 服务端 SDK 开发指南](im-servermgmt-guide-python.html)。

## REST API

参考 [即时通讯 REST API](realtime_rest_api_v2.html)。

