{% import "views/_im.njk" as im %}
# 即时通讯服务总览

即时通讯是 LenaCloud 平台的核心服务之一，主要解决产品内实时数据通讯的需求，其设计上的主要目标是：

* **支持为现有应用快速加入多种通讯能力**<br/>
  我们很多客户的产品都已经达到一个比较稳定的形态，即时通讯只是其中一个锦上添花的功能，所以如何和现有系统无缝集成，是我们设计上一个重要的出发点。LeanCloud 即时通讯服务可以在应用账户系统独立的情况下，快速接入并稳定安全地运行。<br/>
  我们支持了多种典型通讯场景，提供了丰富的 UI 库和脚手架来帮助开发者快速接入。<br/>
  并且考虑到业务运行环境，我们提供了全平台支持的 SDK，不光有支持浏览器（Javascript）、Android、iOS 设备的原生 SDK，也提供 Java、Python、PHP 等服务端 SDK，还可以支持微信小程序和小游戏、Unity 3D 游戏引擎，甚至 Windows Desktop 环境都有合适的 SDK 可选。
* **强大的自定义机制满足业务各种扩展需求**<br/>
  我们内置提供了文本、图片、音视频、地理位置、二进制等多种类型的消息，支持消息撤回与修改、@ 成员提醒、敏感内容实时过滤等高阶需求，也默认提供了强大的系统管理与运营支持能力。<br/>
  我们明白业务系统的复杂性和多样性，所以在设计上预留了很多的自定义接口，允许产品开发者来扩展自己的消息类型、UI 样式以及对对话全流程的控制。
* **最大限度降低客户的生产运维成本**<br/>
  作为专业的通讯云服务提供商，我们希望客户不再担心用户量和流量的突然上涨，无需关心系统日常的运维细节，并且服务使用的费用和实际使用量的多少是正相关的关系，这样的模式才是云服务该有的样子。

LeanCloud 即时通讯服务现在已经被广泛使用在应用内社交、工作协同、客服系统、超大型赛事和电视直播、以及游戏状态同步等多种业务场景之中。

## 功能和特性

LeanCloud 即时通讯服务提供的主要功能有：

* 基本聊天功能，包括：<br/>
  - 支持多种聊天场景。除了普通的单聊、群聊之外，我们还提供不限人数的「开放聊天室」，适合活动直播、公开课、电视红包等海量用户在一个群里突发互动的场合，也提供了可用来实现应用内的公众号、服务号的「系统对话」，还有专为客服系统准备的「临时对话」。通过提炼不同场景的共通需求，我们提供了功能各异但接口一致的解决方案。
  - 用户之间可以发送多种多样的消息，如文本、图片、语音、音视频、地理位置等，也可以发送二进制消息，以及更多的应用层自定义消息。
  - 聊天消息自动保存在云端，支持各种复杂的查找和翻页方式。
* 特殊的消息收发需求。除了普通的消息收发之外，我们还支持：<br/>
  - 带有提醒功能的 @ 消息（如微信里面的 @ 某人）
  - 消息的撤回和修改
  - 消息送达和对方已读的回执通知
  - 支持发送譬如聊天过程中「某某正在输入...」这样的状态信息
  - 在消息接收方离线时，自动转为推送通知（Push Notification）。
  - 对于大型的开放聊天室，为了防止重要消息被淹没或丢弃，支持不同优先级的发送选项，确保重要的消息能优先、迅速送达客户端。
* 多端登录与消息同步<br/>
  现在一个用户使用多个设备登录已经是比较常见的需求，我们既支持单个账号在多个设备同时登录、实时消息同步到所有设备，也支持单点登录，可由业务层自主选择。<br/>
  移动设备网络不稳定也是常态，聊天过程中用户难免会偶尔掉线，我们的消息同步机制可以确保用户消息及时得到同步，重要消息从不丢失。
* 管理与运营支持<br/>
  对于大的群组和开放聊天室，我们提供了管理员、普通成员的权限区分功能，也支持邀请、踢人、黑名单和禁言等众多运营管理需求。<br/>
  对于聊天消息，我们默认提供了实时过滤敏感内容的能力，允许各个产品设置自己的敏感词列表，并且也支持开发者实现自己的敏感词过滤插件，来确保产品运营层面合规合法。
* 安全控制<br/>
  任何终端用户要开启即时通讯服务，只需要提供一个唯一标识自己的 `ClientId` 即可，这种与产品自有账户系统解耦合的方式，带来了集成的便利，也可以促使通讯服务商专注做好底层的「信使」角色。<br/>
  同时我们也提供第三方鉴权的机制，通过在聊天流程中加入开发者服务器签名授权这一环节，来确保通讯操作的安全。<br/>
  而且，即时通讯 SDK 与 LeanCloud 云端是 WebSocket 全双工通讯，且全程使用 TLS 安全加密。
* 强大的业务扩展能力<br/>
  对于很多典型的需求，我们提供了默认的实现，而为了支持业务的多样性和特殊性，我们也提供了丰富的扩展机制。
  - 为了和产品自有用户系统进行对接，我们提供了第三方操作鉴权的扩展接口，确保在用户登录、创建/加入/退出对话群组、以及拉取聊天记录时，所有操作都得到了授权。
  - 同时我们还支持开发者对消息传递的过程进行 hook 处理，在消息到达 LeanCloud 云端但是还没有投递之前和投递之后，分别完成自定义的处理逻辑，例如过滤掉竞品的品牌，以及自定义离线推送消息，等等。
  - 我们也支持通过简单的 web hook 来完成 LeanCloud 云端和应用后端的消息同步。
  - 在提供移动端的 SDK 之外，我们还提供了服务端的 SDK，以帮助产品在可信环境下更好地实现业务处理。
  
  我们相信灵活性和扩展性也是云服务的核心竞争力。

## 全平台 SDK 和 Demo 支持

目前，我们提供了

* Android/Java
* iOS（Objective-C / Swift 两个版本）
* 浏览器（JavaScript）
* Unity
* 微信开发生态（小程序和小游戏）
* Windows Desktop
* 其他游戏平台，如 Cocos Creator、Egret 引擎等

等主要平台的客户端 SDK，而且它们源代码都是公开的，开发者可以在我们的 github 账户下自由下载，可以与我们工程师同步讨论遇到的问题和需求。

在 SDK 之外，我们也公开了一些 Demo 项目来帮助开发者快速熟悉我们的产品：

* iOS 聊天应用：
  * [ChatKit，自带 UI 的聊天工具包](chatkit-ios.html)

* Android 聊天应用：
  * [ChatKit，自带 UI 的聊天工具包](chatkit-android.html)
  * [LeanChat Android 版](https://github.com/leancloud/leanchat-android)

* JavaScript 聊天应用
  * [LeanMessageDemo 网页版](https://github.com/leancloud/leanmessage-demo)
  * [Simple Chatroom](https://leancloud.github.io/js-realtime-sdk/demo/simple-chatroom/)（[源码](https://github.com/leancloud/js-realtime-sdk/tree/next/demo/simple-chatroom)）

关于这些项目的更多介绍、截图预览，可见 [LeanCloud Demos](https://github.com/leancloud/leancloud-demos) 。

## 核心概念说明

在深入了解之前，我们先跟大家解释几个核心概念，这些概念在 API 或者后面的开发指南中都会出现，了解它们会让后续的文档阅读变得简单和轻松很多。

### Client、用户和登录

即时通讯服务中的每一个终端称为一个「Client」。Client 拥有一个在应用内唯一标识自己的 id。这个 id 由应用自己定义，必须是***不超过 64 个字符的字符串***。在大部分场合，Client 都可以对应到应用中的某个「用户」，但是并不是只有真的用户才能做为 Client，你完全可以把一个探测器当成一个 Client，把它收集到的数据通过即时通讯服务广播给更多「人」。

要使用即时通讯服务，每一个终端设备需要首先建立与即时通讯云端的 WebSocket 长连接，并使用唯一的 ClientId 来加入即时通讯服务，我们把这一过程称为「登录」。请注意这里的登录仅仅指客户端登录即时通讯服务，与应用层面的用户账户注册登录是不一样的。

默认情况下，LeanCloud 即时通讯服务允许一个 ClientId 在多个不同的设备上登录，也允许一个设备上有多个 clientId 同时登录。如果使用场景中需要限制用户只在一处登录，可以在登录时明确设置当前设备的 tag，
当 LeanCloud 云端检测到同一个 tag 的设备出现冲突时，会自动踢出已存在设备上的登录状态。开发者可以根据自己的应用场景选择合适的登录方式。

客户端通过即时通讯 SDK 完成登录后，开发者就不必再关心底层的网络连接状态，SDK 会自动为开发者保持连接状态，并在网络状态变化之后进行自动重连。对于 Android 设备，我们使用常驻后台的「服务（Service）」保持在线状态；对于 iOS 和 Windows Phone
设备，当应用在前台时 SDK 会保持连接，而当应用退到后台时，连接自动断开我们默认会激活平台原生的推送服务，来保证消息及时送达。

### 对话（Conversation）

用户登录之后，与其他人进行消息沟通，即为开启了一个「对话（Conversation）」。在即时通讯服务中，「对话」包含了沟通的用户群体，也是所有消息依托的媒介 -- 消息都是由某一个 client 发往一个「对话」。终端用户在开始聊天之前，需要先创建或者加入一个对话，然后再邀请其他人进来（可选），之后所有参与者在这个对话内进行交流。

系统每创建一个对话，就会在云端的 `_Conversation` 表中增加一条记录，可以进入 [控制台 > **存储** > **数据**](/data.html?appid={{appid}}#/) 来查看该数据。

一个「对话」在创建之后，我们还可以给他指定一些应用层的属性，例如名字、自定义的扩展属性，等等。对话的各个属性与 `_Conversation` 表中字段的对应关系为：

属性名|表字段|类型|约束|说明
---|---|---|---|---
**name**|**name**|String|可选|对话的名字，可为群组命名。
**attributes**|**attr**|Object|可选|自定义属性，供开发者扩展使用。
**conversationId**|**objectId**|String||对话 id（只读），由云端为该对话生成的一个全局唯一的 id。
**creator**|**c**|String||对话创建者的 clientId（只读）
**members**|**m**|Array||普通对话的所有参与者（仅针对普通对话，暂态对话和系统对话并不支持持久化的成员列表）
**mute**|**mu**|Array||将对话设为静音的参与者，这部分参与者不会收到推送。<br/>（仅针对 iOS、 Windows Phone 以及开启了混合推送的 Android 用户有效）
**lastMessageAt**|**lm**|Date||对话中最后一条消息的发送或接收时间
**transient**|**tr**|Boolean|可选|对话类型标志，是否为暂态对话，后面会说明
**system**|**sys**|Boolean|可选|对话类型标志，是否是系统对话，后面会说明
**unique**|**unique**|Boolean|可选|内部字段，对话类型标志，标记根据成员原子创建的对话，后面会说明。

虽然我们统一使用 `_Conversation` 表来存储所有对话，但是根据业务场景的不同我们 SDK 里面提供了多种不同的对话类型可供选择。

#### 业务场景的需求

在解释对话类型之前，我们先列举一下即时通讯可能的使用场景。

* **单聊**<br/>
  就是两个 client 之间的对话，公开与否（能否让其他人看到这个对话存在）由应用层自己控制。通常它是私密的，并且加入新的成员之后，会切换成新的群聊（当然，也可以依然不离开当前对话，这一点还是由应用层来决定）。
* **群聊**<br/>
  就是两个（含）以上 client 之间的对话，通常可以添加和删除成员，并且会赋予群聊一个名字，例如家人群、朋友群、部门同事群等等。随着成员的减少，群聊也可能只有两个甚至一个成员（成员的多少并不是区分群聊和单聊的关键）。群聊能否公开（譬如支持名字搜索），由应用自己决定。
* **聊天室**<br/>
  很多直播产品使用的开放聊天室、弹幕、网页直播等都可以抽象成「聊天室」，它与群聊类似，都是多人参与的群组，但是也有一些区别：其一在于聊天室人数可能远大于群聊人数；其二在于聊天室强调的是在线人数，所有参与者进入聊天界面就算加入，关闭界面就算退出，所以聊天室不需要离线消息和推送通知，在线成员数比具体成员列表更有意义。
* **公众号、机器人**<br/>
  很多产品都会加入类似微信的公众号/服务号的功能，让一些特殊的账号给订阅用户发全员广播，也可以和特定用户进行一对一的信息交流。也有一些业务需要实现一个智能机器人的功能，可以自动与其他用户进行交流，解决客服或者问答类的需求。
* **临时客服通道**<br/>
  有一些客服系统，会为每一个反馈问题的终端用户建立一个与在席客服的临时沟通渠道，在通道内用户和客服人员如单聊一般进行沟通，随着问题的解决自动关闭该通道。

下面我们看看如何把上面的业务场景映射到不同的「对话」类型。

#### 普通对话（Conversation）

这是我们使用最多的「对话」，它支持的功能有：

* 成员之间发送和接收消息
* 允许增加、删除成员（最大成员数不超过 500），且会全局通知成员变动事件
* 支持查询成员在线状态
* 支持更多的消息收发选项，例如 @ 成员提醒消息、撤回和修改消息、暂态消息、消息送达和已读的回执通知、Will 消息、离线推送通知等等。
* 部分成员离线状态下，可以收到消息推送通知，并且上线之后会进行消息同步，确保不丢消息。
* 消息记录自动保存在云端，支持多种查询方式。

单聊和群聊都通过它来实现。我们建议开发者将单聊/群聊、私密/公开等属性存入到 Conversation.attributes 之中，在应用层进行区分。

> 使用建议：
> 为了提高系统的灵活性，我们允许多个对话保持相同的成员，因此创建对话时系统总是默认创建新的对话。
如果开发者希望使用固定的对话，可以在创建对话时设置相应 SDK 上的 `unique` 选项，系统将查找对应成员相同且 `unique` 选项为 true 的对话，如果找到即返回已有的对话，如果没有则自动创建。
（注意，这种方式查找的对话仅对已经使用 `unique` 选项的对话有效，并且创建对话时不会触发 `_Conversation` 表在云引擎上的 `beforeSave` 等 hook）

#### 聊天室（ChatRoom）

专门用来处理「聊天室」这种需求的「对话」(在老版本 SDK 中也叫 TransientConversation)，在 `_Conversation` 表中，以 `tr` 为 `true` 来标记。与普通对话一样，它支持创建、自身主动加入、自身主动退出对话等操作，消息记录会被保存并可供获取，但其不同之处在于：

* **不限成员上限**，没有固定成员概念，加入即为成员，断线即为退出（`m`列在系统对话中将被忽略）
* 不支持查询成员列表，你可以通过相关 API 查询在线人数
* 不支持离线消息、离线推送通知、消息回执等功能
* 没有成员加入、离开的通知
* 不支持邀请加入、踢出成员这两个操作
* 一个用户一次登录只能加入一个聊天室，加入新的聊天室后会自动离开旧的聊天室。
* 加入之后如果半小时内断网重连会自动加入原聊天室，超过这个时间则需要重新加入。

> 注意：虽然「聊天室」不限制成员数量，但从实际经验来看，如果人数过多，那么聊天室内消息被放大的效果会非常明显，对于终端用户而言即表现为过量消息不断刷屏，反而影响用户体验。我们建议每个聊天室的上限人数控制在 5000 人左右。开发者可以考虑从应用层面将大聊天室拆分成多个较小的聊天室。

#### 系统对话（System Conversation）

这是用于实现智能机器人、公众号、服务账号等场景的「对话」，也可以用作发送应用内通知的通道，在 `_Conversation` 表中，以 `sys` 为 `true` 来标记。
这种对话具有以下特点：

* 加入即订阅，离开即退订，订阅人数没有限制（`m`列在系统对话中将被忽略）
* 系统对话的创建必须由服务端发起，在客户端仅允许订阅/取消订阅一个已经存在的系统对话
* 可以通过系统对话给所有订阅者发送全局消息，也可以单独某一个或者某几个用户发定向消息
* 用户给系统对话发送的上行消息是单向的，消息和相关信息会存储在数据存储中的 `_SysMessage` 表，并不会被其他订阅用户收到
* 开发者可以配置 [Web Hook](realtime-guide-systemconv.html#Web_Hook) 地址接收用户发给系统对话的消息，并利用 REST API 发消息回复


#### 临时对话（Temporary Conversation）

临时对话是一个全新的概念，其数据不会被保存到 `_Conversation` 表中，它解决的是一种特殊的聊天场景：

- 对话存续时间短
- 聊天参与的人数较少（最多为 10 个 Client Id）
- 聊天记录的存储不是强需求

这种对话场景，我们推荐使用临时对话。比较能够说明这种对话场景的现实需求就是：电商售前和售后的在线聊天的客服系统，可以对比京东或者淘宝的客服。

临时对话在使用上与普通对话类似，其最大特点是较短的有效期（不会被保存到 `_Conversation` 表中），这带来的优势是可以减轻对话的持久化存储在服务端占用的存储资源规模，从而降低开发者的使用成本。


#### 不同类型的对比总结

功能点 | 普通对话 | 聊天室 | 系统对话 | 临时对话
--- | --- | --- | ---
**使用场景** | 单聊、群聊 | 聊天室、弹幕、网页实时评论 | 公众号、机器人、下发加好友通知、自定义消息 | 
**成员管理** | 成员持久化保存，<br/>最高支持 500 个成员 | 没有持久化的成员数据，<br/>但支持成员没有上限 | 没有成员概念，<br/>开发者维护订阅关系，<br/>订阅人数没有上限 | 
**收发消息** | 只有成员可以收发消息 | 所有用户都可以发消息，<br/>当前在线的成员可以收到消息 | 开发者通过 API 给特定用户发消息，<br/>用户发送的消息到达数据库和业务方配置的 Web Hook | 
**消息记录** | 支持 | 支持 | 支持 | 支持

### 消息（Message）

即时通讯服务中单次交互的数据单元。用户可以一次传输不超过 **5 KB** 的消息数据。在底层即时通讯允许开发者传输任何基于文本的消息数据，即时通讯系统对消息格式没有任何要求，
开发者可以在文本协议基础上定义自己的应用层协议。

根据发送参数的不同，消息可分为「普通消息」和「暂态消息」。LeanCloud 云端对于普通消息会提供接收回执、自动持久化存储、离线推送等功能。
但是暂态消息，则不会被自动保存，也不支持延迟接收，离线用户更不会收到推送通知。譬如聊天过程中「某某正在输入中...」这样的状态信息，就适合按照暂态消息来发送，而用户输入的正式消息，则应该用普通消息来发送。

我们对普通消息提供「至少一次」的到达保证，并且在官方 SDK 中支持对消息的去重，开发者无需关心。除了基于「推」模型的消息机制，我们还提供消息记录的机制允许
SDK 和 REST API 通过「拉」的方式获取任意时间点前的消息。

开发者可以通过 SDK 或 REST API 发送消息。SDK 通常用于最终用户发送消息，而 REST API 是开发者从云端发送消息的接口。当从 REST API
发送消息时，开发者可以指定消息的发送者、对话 ID，对于系统对话还可以指定消息的接收者。

#### 内建支持的富媒体消息

为了方便开发者的使用，我们提供了几种封装好的基于 JSON 格式的富媒体消息类型（TypedMessage），譬如：

- 文本（TextMessage）
- 图片（ImageMessage）
- 音频（AudioMessage）
- 视频（VideoMessage）
- 位置（LocationMessage）

这些消息类型可最大程度地简化使用步骤，能更好地满足通用需求。开发者也可以基于我们的框架，方便地扩展出自己的消息类型。

这些消息类型的层次关系为：

```
                                    Message
                                       |
                                  TypedMessage
                                       |
     __________________________________|__________________________________
     |             |            |             |               |           |
TextMessage  ImageMessage  AudioMessage  VideoMessage  LocationMessage   。。。
```

关于这部分消息的格式请参考
[《即时通讯 REST API - 富媒体消息格式说明》](realtime_rest_api.html#富媒体消息格式说明)了解。

#### 与消息相关的其他功能需求

前面章节说明功能特性的时候，我们提到过，在正常收发消息之外我们还支持：

  - 带有提醒功能的 @ 消息（如微信里面的 @ 某人）
  - 消息的撤回和修改
  - 消息内容的实时过滤
  - 消息送达和对方已读的回执通知
  - 支持发送譬如聊天过程中「某某正在输入...」这样的状态信息
  - 在消息接收方离线时，自动转为推送通知（Push Notification）。
  - 对于大型的开放聊天室，为了防止重要消息被淹没或丢弃，支持不同优先级的发送选项，确保重要的消息能优先、迅速送达客户端。

具体的使用方法可以参考文档[消息收发的更多需求](realtime-guide-intermediate.html#消息收发的更多需求)和[消息的内容过滤](realtime-guide-intermediate.html#聊天室消息的内容过滤)。


## 系统限制

* 对于客户端主动发起的操作会按照操作类型限制其频率。发消息操作限制为 **每分钟 60 次**，历史消息查询操作限制为 **每分钟 120 次**，其他类型操作包括加入对话、离开对话、登录服务、退出服务等均限制为 **每分钟 30 次**。当调用超过限制时，云端会拒绝响应这些超限的操作，这样如果操作本由 SDK 发起则表现为不会走回调。如果使用 REST API 发起各种操作，则不会受到上述频率的限制。
* 应用全局服务器下发消息速度默认为每秒钟 160000 次，超过部分会被服务器丢弃。如果你的应用会超过此限制，请 [联系我们](/help.html)。
* 通过 API 发送的消息有发送速率限制。最高每秒钟 50 次请求，超过该速率后服务器会对发送的消息做排队缓存，如果排队待发送的消息超过 10000 条则会拒绝新来的发消息请求。
* 客户端发送的单条消息大小不得超过 5 KB。
* 单个普通对话的成员上限为 500 个，如果您通过数据存储 API 向 m 字段加入了超过 500 个 id，我们只会使用其中的前 500 个。
* 请不要使用相同的 id 在大量设备上同时登录，如果系统检测到某个 id 同时在超过 5 个不同的 IP 上登录，会认为此 id 是重复使用的 id，之后此 id 当日的每次登录会按照 `id + IP` 的组合作为计费的独立用户。
* 如果单个用户有超过 50 个的对话存在未接收的离线消息，那么当该用户登录时服务端只会**随机**下发 50 个对话的离线消息或未读消息数量。也就是说服务端不会再下发超出对话数量限制的那部分离线消息，也不会下发离线消息数量，离线消息不会丟失但需要从历史记录中拉取得到。
* 单个对话未接收的离线消息数最多 100 条，超过后，系统会以先入先出方式存储新的离线消息，同时移除当前对话存储的最早的一条离线消息。被移除的离线消息可以通过历史消息记录查询，但不会产生离线消息提醒，也不会计入对话的未读消息计数。
* 系统广播消息一个应用一天最多发 30 条

{{ im.conversationsLifespan("### 对话的有效期") }}

{{ im.messagesLifespan("### 消息的有效期") }} 


## 即时通讯 Hook 机制

详见 [消息 hook 接口和系统对话使用详解](realtime-guide-systemconv.html#万能的 Hook 机制)。

## 开发指南

按功能区分，可以参考如下文档：
- [第一章：从简单的单聊、群聊、收发图文消息开始](realtime-guide-beginner.html)
- [第二章：更多消息收发的需求，开放聊天室以及内容实时过滤](realtime-guide-intermediate.html)
- [第三章：安全与签名、黑名单和权限管理、多端登录与消息同步](realtime-guide-senior.html)
- [第四章：详解消息 hook 与系统对话，打造自己的聊天机器人](realtime-guide-systemconv.html)

按客户端开发语言和平台区分，可以参考：
- [Android 开发指南](realtime_guide-android.html)
- [iOS 开发指南](realtime_guide-objc.html)
- [JavaScript 开发指南](realtime_guide-js.html)。

服务端开发指南，可以参考：[Python 服务端 SDK 开发指南](im-servermgmt-guide-python.html)。

## REST API

参考 [即时通讯 REST API](realtime_rest_api_v2.html)。

